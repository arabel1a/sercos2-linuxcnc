/*
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 */
#include "sercos-mdt-gen.h"


uint16_t CRC(const uint8_t *Buffer, uint8_t Length)
{
   uint16_t retVal = 0u;
   uint8_t byteIndex = 0u;

    if(Buffer != NULL)
    {
		retVal = CRC_16_INIT_VALUE;

		/* Update the CRC using the data */
		for(byteIndex = 0u; byteIndex < Length; byteIndex++)
        {
			retVal = (retVal << 8u) ^ CRC16Table[(retVal >> 8u) ^ Buffer[byteIndex]];
		}

		/* XOR result with specified value */
		retVal ^= CRC_16_XOR_VALUE;
	}

   return retVal;
}


void reverse(uint8_t * sData, uint8_t * dData , uint16_t length)
{
	uint8_t tmp[length];
	for(int i = 0; i < length; i++)	tmp[length - i - 1] = lookup[ *(sData + i) & 0xf ] << 4 | lookup[*(sData + i) >> 4];
	for(int i = 0; i < length; i++) dData[i] = tmp[i];
	return;
}

void nrzi(uint8_t *sData, uint8_t *dData, uint16_t size, bool enc)
{
	/*
	enc   : true for encode, false for decode
	sData : source 
	dData : destination
	*/
		
	uint8_t temp_byte;
	bool NRZI_last_bit_d, NRZI_last_bit_e = false;
	NRZI_last_bit_d = (~sData[0] >> 7)%2; 
	for(int i = 0; i < size; i++){
		if(enc){
			temp_byte = ~sData[i];
			temp_byte = temp_byte ^ (temp_byte >> 1) ^ (temp_byte >> 2) ^ (temp_byte >> 3) ^ (temp_byte >> 4) ^ (temp_byte >> 5) ^ (temp_byte >> 6) ^ (temp_byte >> 7);
			dData[i] = NRZI_last_bit_e ? ~temp_byte : temp_byte;
			NRZI_last_bit_e = dData[i] % 2;
		}
		else{
			temp_byte = (sData[i] >> 1) + ((uint8_t) NRZI_last_bit_d << 7);
			dData[i] = ~(sData[i] ^ temp_byte);
			NRZI_last_bit_d = sData[i]  % 2;
		}
	}
	NRZI_last_bit_e = false;
}

/*         insert a zero after 5th 1, also 2 additional 0 athhe start         */

int total_stuffed = 0;
int curr_raw_len;

int bit_stuff(uint8_t *sData, uint8_t *dData, uint16_t size, bool enc)  {
	uint16_t bytenum = 0, shift = 2, cnt = 0;
	bool bit, over = false;
	dData[0] = 128 + 64;
	if(enc){
		for(int i = 0; i < size; i++)
		{	
			for(int j = 0; j < 8; j++)
			{
				bit = ( (sData[i] & ids[j]) == ids[j] );
				if(bit)
				{
					cnt++;
					dData[bytenum] = dData[bytenum] | ids[shift];
				}
				else
					cnt = 0;					
				shift++;
				if(cnt == 5 ){
					if(i != 0 && i != size - 1)
						shift++;
					cnt = 0;
				}
				if(shift >= 8)
				{
					shift -= 8;
					bytenum++;
					dData[bytenum] = 0;
				}
			}
		}
		dData[bytenum] = dData[bytenum] | (uint8_t)((uint16_t) ((1 << (8 - shift)) - 1));
	}
	else
	{
	/*      REALLY BAD 7E FINDING!!!!                  */
		total_stuffed = 0;
		shift 	= 0;
		dData[0] = 0;	
		for(int i = 0; i < size; i++)
		{
			for(int j = over ? 1 : 0; j < 8; j++){
				over = false;
				bit = ( (sData[i] & ids[j]) == ids[j] );
				if(bit)
					cnt++;
				else
					cnt = 0;
				if(bit)
					dData[bytenum] = dData[bytenum] | ids[shift];
				shift++;
				if(cnt == 5){
					j++;
					if(curr_raw_len >= i*8 + j)
						total_stuffed++;
					if(j == 8)
					{
						over = true;
					}
					cnt = 0;
				}
				if(shift >= 8)
				{
					shift -= 8;
					bytenum++;
					dData[bytenum] = 0;
				}
			}
		}
		
	}
	if(shift > 0)
		return bytenum + 1;
	return bytenum;
}


union  {
	int16_t idn;
	uint8_t byte[2];
}IDN2;

union  {
	int32_t idn;
	uint8_t byte[4];
}IDN4;


union idn {
	int idn;
	uint8_t byte[4];
};



int sercos_mdt_gen(int DriveCount, SercosDrive drives[], uint8_t* dData){
	//rtapi_print("mgenb");
	uint8_t nrzi_msg[MAX_MESSAGE_SIZE], raw_msg[MAX_MESSAGE_SIZE], bs_msg[MAX_MESSAGE_SIZE], tmp_msg[MAX_MESSAGE_SIZE];
	for (int ll = 0; ll < MAX_MESSAGE_SIZE; ll++){
		raw_msg[ll] = 0;
		nrzi_msg[ll] = 0;
		bs_msg[ll] = 0;
		tmp_msg[ll] = 0;
	}
	raw_msg[0] = header[0];
	raw_msg[1] = header[1];
	int index = 2;

	//for(int i = 0; i < DriveCount; ++i)
	for(int i = 0; i < DriveCount; ++i)
	{
		raw_msg[index++] =(uint8_t) ( drives[i].ControlWord / 256 );
		raw_msg[index++] =(uint8_t) ( drives[i].ControlWord % 256 );
		raw_msg[index++] =(uint8_t) ( drives[i].Service_out / 256 );
		raw_msg[index++] =(uint8_t) ( drives[i].Service_out % 256 );
		for(int j = 0; j <  drives[i].idn_out_number; j++){
			switch(drives[i].idn_out_size[j])
			{
				case 4:
					IDN4.idn = drives[i].idn_out[j];

					raw_msg[index++] =(uint8_t) IDN4.byte[3];
					raw_msg[index++] =(uint8_t) IDN4.byte[2];
					raw_msg[index++] =(uint8_t) IDN4.byte[1];
					raw_msg[index++] =(uint8_t) IDN4.byte[0];
					reverse(raw_msg + index - 4, raw_msg + index - 4, 4 );	
					break;
				
				case 2:
					//union idn2 IDN;
					IDN2.idn = (short) drives[i].idn_out[j];	
					raw_msg[index++] =(uint8_t) IDN2.byte[1];
					raw_msg[index++] =(uint8_t) IDN2.byte[0];
					reverse(raw_msg + index - 2, raw_msg + index - 2, 2);			
					break;

				case 1:
					raw_msg[index++] = drives[i].idn_out[j];			
					reverse(raw_msg + index - 1, raw_msg + index - 1, 1);			
					break;
			}
		}

	}
	uint16_t FCS = CRC(raw_msg + 1, 33);
	raw_msg[34] = (uint8_t) (FCS / 256 );
	raw_msg[35] = (uint8_t) (FCS % 256 );
	raw_msg[36] = tail;
	int len = bit_stuff(raw_msg, bs_msg, 37, true);
	nrzi(bs_msg, nrzi_msg, len, true);
	for(int i = 0; i < len; i++) dData[i] = nrzi_msg[i];
	return len;
}

int fefind(uint8_t* sData, int size, int startpos){
/*		Returns position of another bit after 7 equal bits in MSG	*/
	int last_bit = 0, bit_cnt = 0, shift, byte;
	
	byte = startpos / 8;
	shift = 7 - ( startpos % 8 );
	bool flag = false;

	for(; byte < size; byte ++){
		for(; shift >= 0; shift--)
		{
			uint8_t current_bit = ( sData[byte] >> shift ) % 2;
			if( current_bit == last_bit)
				bit_cnt++;
			else{
				if(bit_cnt == 7){	
					flag = true;
					break;
				}
				bit_cnt  = 1;
				last_bit = current_bit;				
			}
		}
		if(flag)
			break;
		shift=7;
	}


	if(bit_cnt == 7)
	{
		return byte * 8 + 7 - shift ;
	}
	return -1;
}

void bit_cpy(uint8_t* sData, uint8_t* dData, int size, int shift)
{
	uint8_t data;
	for(int i = 0; i < size - 1; i++)
	{
		data = (sData[i] << shift) + (sData[i+1] >> (8 - shift));
		dData[i] = data;
	}
	data = sData[size - 1] << shift;
	dData[size - 1] = data;
}



int sercos_dt_read(int DriveCount, SercosDrive drives[], uint8_t* sData, int size){
	int error = 0;
	
	/*		find all frame delimeters		*/
	int points[DriveCount][20 * DriveCount], points_num[DriveCount];
	int pos = 1;
	
	for(int j = 0; j < DriveCount; j++)
	{
		points_num[j] = 0;
		int pos = j*MAX_DT_SIZE*8;
		points[j][points_num[j] ++]	=  pos;		
		for(int i = 0; i < 21; i++)
		{
			if(i == 20){
				if(verbose > 0) rtapi_print("warning: >20 points per drive %d \n", j);
				break;
			}
			pos = fefind(sData , MAX_DT_SIZE * (j+1), pos + 1);
			if(pos < 0) break;
			points[j][points_num[j] ++]	= 	pos;
		}

		if ( points_num[j] <  2){
			if(verbose > 0) rtapi_print("WARNING: FD not found(drive %d)\n", j);
			error |= 1 << j;
		}
	}


	/*		split intro dt's				*/
	uint8_t raw_DT [	DriveCount ][ MAX_DT_SIZE ], curr_drv = 0;
	uint8_t nrzi_DT[	DriveCount ][ MAX_DT_SIZE ], bs_DT[	DriveCount ][ MAX_DT_SIZE ];
	for(int j = 0; j < DriveCount; j++) 
		for(int i = 0; i < MAX_DT_SIZE; i++) { 
			raw_DT[j][i] 	=	0; 
			nrzi_DT[j][i] 	= 	0; 
			bs_DT[j][i]		=	0;
		}	

	int raw_len[DriveCount];

	for(int j = 0; j < DriveCount; j++){
		if(error & (1<< j)) continue;
		// searching for points with enought distance
		int i = 0;
		while(i < points_num[j] - 1 && points[j][i + 1] - points[j][i]  < MIN_DT_LEN * 8){ 
			i++; 
		}
		if ( i >= points_num[j] - 1){
				if(verbose > 0) rtapi_print(" No good points for drive %d \n", j);
				error |= 1<< j;	
				continue;
			}

		raw_len[j]	=	points[j][i + 1] - points[j][0] - 8;
		int llen = raw_len[j]/ 8 + 2 - ( 8 - raw_len[j] % 8)/8;
		bit_cpy(sData + (points[j][0]) / 8, raw_DT[j], llen, (points[j][0]) % 8);

		//check that there is no good points
		i++;
		while(i < points_num[j] - 1 && points[j][i + 1] - points[j][i]  < MIN_DT_LEN * 8){ i++; }
		if ( i < points_num[j] - 1){
				if(verbose > 0) rtapi_print(">1 point candidate for drive %d \n", j);
				error |= 1<< j;	
			}
	}

	for(int j = 0; j < DriveCount; j++)
	{
		if(error & (1<< j)) continue;
		nrzi(raw_DT[j], nrzi_DT[j], MAX_DT_SIZE, false);
		curr_raw_len = raw_len[j];
		int llllll =  bit_stuff(nrzi_DT[j], bs_DT[j], MAX_DT_SIZE, false);
		int true_len = raw_len[j] - total_stuffed;
		int extra_bits = true_len - 15*8 + 1;
		bit_cpy(bs_DT[j] + extra_bits / 8, bs_DT[j], llllll, extra_bits % 8);

	}
	
	for(int j = 0; j < DriveCount; j++)
	{
		drives[j].rx_ok = false;

		if(error & (1<< j)) continue;

		uint16_t FCS = CRC(bs_DT[j], DT_FCS_POS);

		if(bs_DT[j][DT_FCS_POS] != (uint8_t) (FCS / 256 ) || bs_DT[j][DT_FCS_POS + 1] != (uint8_t) (FCS % 256 ))
		{
			if(verbose > 0) {
				rtapi_print( "Warning: CRC mismarch for drive telegramm %d, skipping\n", j);
				for(int i = 0; i < DT_FCS_POS + 2; i++) rtapi_print("%02x:",  bs_DT[j][i]);
				rtapi_print("\n");

			}
			error |= 1 <<j;
			continue;
		}
		uint8_t addr[1], status[2], service[2];
		reverse(bs_DT[j], addr , 1);
		reverse(bs_DT[j] + 1, status , 2);
		reverse(bs_DT[j] + 3, service, 2);
		
		if(addr[0] != (uint8_t) drives[j].addr)
		{
			if(verbose > 0) {
				rtapi_print( "Warning: address mismarch for drive telegramm %d, skipping\n", j);
				for(int i = 0; i < DT_FCS_POS + 2; i++) rtapi_print("%02x:",  bs_DT[j][i]);
				rtapi_print("\n");
			}
			error |= 1 <<j;
			continue;
		}

		drives[j].StatusWord = status[0]*256 + status[1];
		
		drives[j].Service_out = service[0]*256 + service[1];
		
		int curr_byte = 5;
		for(int k = 0; k < drives[j].idn_in_number; k++)
		{
			if(curr_byte >= DT_FCS_POS){
				if(verbose > 0) rtapi_print("Warning: get more idns than expexted in DT %d\n", j);
				error |= 1 << j;
				break;
			}
			int value;					
			uint8_t tmp[4];

			switch(drives[j].idn_in_size[k])
			{
				case 4:
					tmp[3] = bs_DT[j][curr_byte];
					tmp[2] = bs_DT[j][curr_byte+1];
					tmp[1] = bs_DT[j][curr_byte+2];
					tmp[0] = bs_DT[j][curr_byte+3];
					reverse(tmp, IDN4.byte , 4);
					value = IDN4.idn;
					break;
									
				case 2:
					tmp[1] = bs_DT[j][curr_byte];
					tmp[0] = bs_DT[j][curr_byte+1];
					reverse(tmp, IDN2.byte , 2);
					value = IDN2.idn;
					break;
			}
			
			drives[j].idn_in[k] = value;
			curr_byte += drives[j].idn_in_size[k];

		}

		if(error & (1<< j)) continue;
		
		drives[j].rx_ok = true;
	}
	return error;
}



/*int main(){
	int DriveCount = 4;
	SercosDrive drives[DriveCount];
	for(int j = 0; j < DriveCount; j++)
	{
		drives[j].addr				= j + 1;
		drives[j].idn_in_number 	= 3;
		drives[j].idn_in_size[0] 	= 2;
		drives[j].idn_in_size[1] 	= 4;
		drives[j].idn_in_size[2] 	= 2;
	}
	uint8_t test[] = 		{ 0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x08, 0x00, 0x44, 0xfc, 0x0d, 0x55, 0xea, 0xf0, 0xfe, 0x55, 0xaa, 0xb9, 0x55, 0x55, 0x55, 0x55, 0x50, 0x78, 0x55, 0x55, 0x2a, 0xaa, 0xd3, 0xae, 0xfe, 0x80, 0x7f, 0x80, 0x6a, 0xd5, 0x5c, 0xaa, 0xaa, 0xaa, 0xaa, 0xfb, 0x7b, 0x6a, 0xaa, 0xd5, 0x55, 0x68, 0x81, 0xc0, 0x43, 0xfc, 0xfe, 0x2a, 0x55, 0x46, 0xaa, 0xaa, 0xaa, 0xaa, 0x05, 0xd2, 0xaa, 0xaa, 0xea, 0xaa, 0xb3, 0x19, 0x80, 0x80, 0x7f, 0x4a, 0xd5, 0x5c, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xf8, 0x4e, 0xaa, 0xaa, 0xaa, 0xb7, 0xeb, 0x40, 0x43, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	int test_len = 264;
	
	
	
	uint8_t _1drv[]  = {0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x08, 0x00, 0x44, 0xfc, 0x0d, 0x55, 0x55, 0xe0, 0x1f, 0x6a, 0xd5, 0x5c, 0xaa, 0xaa, 0xef, 0x29, 0xd5, 0x55, 0x63, 0xb1, 0x7f, 0x78, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	uint8_t _2drva[] = {0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x08, 0x00, 0x44, 0xf0, 0x1f, 0x81, 0xaa, 0x1f, 0xe0, 0xd5, 0x29, 0x5c, 0xaa, 0xaa, 0xaa, 0xaa, 0xf6, 0xeb, 0x4a, 0xaa, 0xf5, 0x55, 0x6f, 0x82, 0x80, 0x80, 0x7f, 0xea, 0xd5, 0x5c, 0xaa, 0xaa, 0xaa, 0xaa, 0xf9, 0x68, 0x4a, 0xaa, 0xa5, 0x55, 0x5a, 0xc0, 0xbf, 0xbf, 0x80, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	uint8_t _2drvb[] = {0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x08, 0x00, 0x44, 0x0f, 0xe0, 0x7e, 0x55, 0xe0, 0x1f, 0x2a, 0xd6, 0xa3, 0x55, 0x55, 0x55, 0x55, 0x09, 0x14, 0xb5, 0x55, 0x0a, 0xaa, 0x90, 0x7d, 0x7f, 0x7f, 0x80, 0x15, 0x2a, 0xa3, 0x55, 0x55, 0x55, 0x55, 0x06, 0x97, 0xb5, 0x55, 0x5a, 0xaa, 0xa5, 0x3f, 0x40, 0x40, 0x7f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	uint8_t _3drva[] = {0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x08, 0x00, 0x44, 0xfc, 0x0d, 0x55, 0x55, 0x80, 0x7f, 0x6a, 0xd5, 0x5c, 0xaa, 0xaa, 0xaa, 0xaa, 0xef, 0x29, 0xd5, 0x55, 0x55, 0x55, 0x24, 0xcf, 0x7f, 0x7f, 0x00, 0xff, 0xea, 0xd5, 0x5c, 0xaa, 0xaa, 0xaa, 0xaa, 0xf9, 0x68, 0x4a, 0xaa, 0xaa, 0xaa, 0xa4, 0x11, 0x80, 0x8f, 0xf0, 0xb5, 0x2a, 0xa3, 0x55, 0x55, 0x55, 0x55, 0x73, 0xd5, 0xb1, 0x55, 0x2a, 0xaa, 0x85, 0x09, 0x80, 0x80, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	uint8_t _3drvb[] = {0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x08, 0x00, 0x44, 0x03, 0xf2, 0xaa, 0xaa, 0x7f, 0x80, 0x95, 0x2a, 0xa3, 0x55, 0x55, 0x55, 0x55, 0x6f, 0x29, 0xd5, 0x55, 0x55, 0x55, 0x68, 0xd0, 0x80, 0x9f, 0xe0, 0xea, 0xd5, 0x5c, 0xaa, 0xaa, 0xaa, 0xaa, 0xf9, 0x68, 0x4a, 0xaa, 0xaa, 0xaa, 0xa4, 0x11, 0x80, 0x81, 0xfe, 0x4a, 0xd6, 0xa3, 0x55, 0x55, 0x55, 0x55, 0x73, 0xd5, 0xb1, 0x55, 0x55, 0x55, 0x77, 0x32, 0x7f, 0x60, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	uint8_t _3drvc[] = {0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x08, 0x00, 0x44, 0x03, 0xf2, 0xaa, 0xaa, 0x7f, 0x80, 0x95, 0x2a, 0xa3, 0x55, 0x55, 0x55, 0x55, 0x10, 0xd6, 0x2a, 0xaa, 0xaa, 0xaa, 0xdb, 0x30, 0x80, 0x9f, 0xe0, 0xea, 0xd5, 0x5c, 0xaa, 0xaa, 0xaa, 0xaa, 0xf9, 0x68, 0x4a, 0xaa, 0xaa, 0xaa, 0xa4, 0x11, 0x80, 0x81, 0xfe, 0x4a, 0xd6, 0xa3, 0x55, 0x55, 0x55, 0x55, 0x73, 0xd5, 0xb1, 0x55, 0x55, 0x55, 0x77, 0x32, 0x7f, 0x60, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	uint8_t _4drva[] = {0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x08, 0x00, 0x44, 0xfc, 0x0d, 0x55, 0x55, 0xf0, 0x0f, 0xfe, 0x55, 0xaa, 0xb9, 0x55, 0x55, 0x55, 0x55, 0xed, 0xd6, 0x95, 0x55, 0xaa, 0xaa, 0xdb, 0xae, 0xfe, 0x80, 0x7f, 0x6a, 0xd5, 0x5c, 0xaa, 0xaa, 0xaa, 0xaa, 0x90, 0xd6, 0x2a, 0xaa, 0xaa, 0xaa, 0x97, 0x2f, 0x7f, 0x7c, 0x03, 0x01, 0xd5, 0xaa, 0xb9, 0x55, 0x55, 0x55, 0x55, 0xf2, 0xd0, 0x95, 0x55, 0xaa, 0xaa, 0xa5, 0x33, 0x01, 0x7f, 0x80, 0xb5, 0x2a, 0xa3, 0x55, 0x55, 0x55, 0x55, 0x73, 0xd5, 0xb1, 0x55, 0x55, 0x55, 0x73, 0x81, 0x3f, 0xbc, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	uint8_t _4drvb[] = {0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x08, 0x00, 0x44, 0x03, 0xf2, 0xaa, 0xaa, 0x1f, 0xf0, 0x0f, 0x01, 0xaa, 0x55, 0x46, 0xaa, 0xaa, 0xaa, 0xaa, 0x12, 0x29, 0x6a, 0xaa, 0x55, 0x55, 0x24, 0x51, 0x01, 0x7f, 0x80, 0x95, 0x2a, 0xa3, 0x55, 0x55, 0x55, 0x55, 0x6f, 0x29, 0xd5, 0x55, 0x55, 0x55, 0x68, 0xd0, 0x80, 0x83, 0xfc, 0xfe, 0x2a, 0x55, 0x46, 0xaa, 0xaa, 0xaa, 0xaa, 0x0d, 0x2f, 0x6a, 0xaa, 0x55, 0x55, 0x5a, 0xcc, 0xfe, 0x80, 0x7f, 0x4a, 0xd5, 0x5c, 0xaa, 0xaa, 0xaa, 0xaa, 0x8c, 0x2a, 0x4e, 0xaa, 0xaa, 0xaa, 0x8c, 0x7e, 0xc0, 0x43, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	uint8_t _4drvc[] = {0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x08, 0x00, 0x44, 0x03, 0xf2, 0xaa, 0xaa, 0x1f, 0xf0, 0x0f, 0x01, 0xaa, 0x55, 0x44, 0xaa, 0xaa, 0xaa, 0xaa, 0x16, 0x0f, 0x2a, 0xaa, 0x55, 0x55, 0xd9, 0xf1, 0x01, 0x7f, 0x80, 0x95, 0x2a, 0xa2, 0x55, 0x55, 0x55, 0x55, 0x1f, 0x50, 0x55, 0x55, 0x55, 0x55, 0x6d, 0xd8, 0x80, 0x83, 0xfc, 0xfe, 0x2a, 0x55, 0x44, 0xaa, 0xaa, 0xaa, 0xaa, 0x0d, 0x2f, 0x6a, 0xaa, 0x55, 0x55, 0x0a, 0x60, 0xfe, 0x80, 0x7f, 0x4a, 0xd5, 0x5d, 0xaa, 0xaa, 0xaa, 0xaa, 0xa3, 0xd5, 0xb1, 0x55, 0x55, 0x55, 0x67, 0x5c, 0x7f, 0x7c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	uint8_t _4drvd[] = {0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x08, 0x00, 0x44, 0x03, 0xf2, 0xaa, 0xaa, 0x0f, 0xf0, 0x01, 0xaa, 0x55, 0x44, 0xaa, 0xaa, 0xaa, 0xaa, 0x16, 0x0f, 0x2a, 0xaa, 0x55, 0x55, 0xd9, 0xf1, 0x01, 0x7f, 0x80, 0x95, 0x2a, 0xa2, 0x55, 0x55, 0x55, 0x55, 0x1f, 0x50, 0x55, 0x55, 0x55, 0x55, 0x6d, 0xd8, 0x80, 0x83, 0xfc, 0xfe, 0x2a, 0x55, 0x44, 0xaa, 0xaa, 0xaa, 0xaa, 0x0d, 0x2f, 0x6a, 0xaa, 0x55, 0x55, 0x0a, 0x60, 0xfe, 0x80, 0x7f, 0x4a, 0xd5, 0x5d, 0xaa, 0xaa, 0xaa, 0xaa, 0xa3, 0xd5, 0xb1, 0x55, 0x55, 0x55, 0x67, 0x5c, 0x7f, 0x7c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};


	//uint8_t test4[] = {0x7f, 0x55, 0xcc, 0xcc, 0xcc, 0xcc, 0xaa, 0xfc, 0x08, 0x40, 0x40};
	//sercos_dt_read(1, drives, test4, 11);
	
	sercos_dt_read(DriveCount, drives, _4drvd+15, test_len - 15);
	
	
	for(int j = 0; j < DriveCount; j++)
	{
		rtapi_print("DT # %d\n Addres: %d\n, IDN_number: %d \n",j, drives[j].addr, drives[j].idn_in_number);
		for(int i = 0; i < drives[j].idn_in_number;i++)
			rtapi_print("IDN # %d, value: %d \n", i,  drives[j].idn_in[i]);
	}
	
	
	
	
	uint8_t abc[] = {0xaa, 0xaa, 0xff, 0xff};
	uint8_t abc2[] = {0,0,0,0};
	
}
*/
